Problems Index
//******//
Best practise:
1)Draw example in draft/sketch
2)Generate test cases to run the code

Something to Look at:
1)Java Generic operations on Deque/PriorityQueue/Stack
2)Prepare Questions to ask
3)Prepare Project highlights and contributions

/****************************************************************/
/****Topic 1: Tree***********************************************/
/****************************************************************/
1)Populating Next Right Pointers in Each Node O(1) space O(N) time  
    a)Any binary tree
    leverage parent next pointer, consider different cases for left/right children

2)Flatten Binary Tree to Linked List, using rightChild link as next pointer
    a)PreOrder solution[LeetCode]
    b)If the BinaryTree is search tree, return in-order solution[NonLeetCode]
    Keep track of leftMost/rightMost for each node, update accordingly in recursion   
    c)Convert Sorted Array to Balanced Binary Search Tree
    //Binary Cut Recursion 
    d)Convert Sorted List to Balanced Binary Search Tree [Practice]
    //convert to ArrayFirst or do it with nice recursion 
    e) Determine if a BST is valid
    (Needs MetaData min, max, isValid) 

3)Sum of Path(from root to leaf) equals to K
    a)determine if there is one solution
    b)fetch all solutions
    Recursion with K-root.getValue() down to root children, use a shared List to remember path
    and another list to remember all results
    c)If the path may start/end at any node in the tree(rather than only from root to leaf), find the max sum
    //Recursion with MetaData{
        int maxPathRootWithNode
        int maxPathUnderSubTreeNode
    }see LeetCode Solution for detailed relationship    
    d)Sum Root to Leaf Numbers(each node only from 0-9 and represents one digit of a number)
    Post Preorder pass parent sum value, Order to retrive sum 

4)Min/Max Depth of a Tree
    a)Max Depth of a Tree can do simple recursion but Min Depth cannot, as null return 0, max depth will not be affected, however, minDepth will cause a node with one null child and another not null child is not height 1, but non-null child height+1
    b)Therefore Max depth works for simple recursion but MinDepth needs more check
    c)We can use BFS to solve the problem, Min is the nearest leaf node return and Max is the farthest leaf node return (How to keep track of level: swap two lists or use two seperate Queue)
    d)Balanced Binary Search Tree
    //Similar recursion but needs two information, height and isBalanced, can use integer -1 to merge these two information in one data type 

5)Binary Tree Level Order Print
    a)From Top to bottom, print level
    //BFS with MetaData, Two Queue, Multiple Lists
    b)Pring from bottom to top
    //Insert in the front of the list, or use a stack to reverse, or just reverse
    c)From top to bottom in Zig-Zag
    //multiple lists: use a lable to mark left-right/right-left insert into the List 
    //Queue:Use a stack to reverse in case of need reverse

6)From In Order + (Post/Pre Order) to construct a Binary Tree
    a)Post+Pre does not work

7)Tree Similarity
    a)Determine if it is same tree?
    b)Determine if it is symmetric tree?

8)Structureally unique Binary Search Trees for nodes from 1 to N
    a)How many of them?How to build them?
    //use recursion, combinations of possible left/right children node numbers
    h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (where n>=2，h(0) = h(1) = 1) 
    [Catalan Number]    h(n)=C(2n,n)/(n+1) (n=1,2,3,...)
    b)n pair of parenthesis, how many possible ways to match them?
    //f(2n) = f(0)*f(2n-2) + f(2)*f(2n - 4) + ... + f(2n - 4)*f(2) + f(2n-2)*f(0)
    //f(0)*f(2n-2) means the 0th and 2n-1th element matches, and then it goes recursively to
    //the 2n-2 elements in the between; f(2n) = h(n)
    c)one infinite stack has in-stack sequece 1,2,3...n-1,n, what's the number of possible
    out-stack sequence? h(n) how about out-stack 1,2,3,...n and possible ways of in-stack?
    d)2n points on the circule, the number of ways to connect the 2n points using n lines
    e)n matrix multiply chain, the ways to parenthesis the chain is h(n): P=a1×a2×a3×……×an
    f)number of ways from (0,0) to (n,n): only right, and up is allowed and cannot exceed the diagnose, h(n)
    g)2K people in two row, each row has n people and sorted by increasing height order, the person in the back row has to be higher than the person in front of him, what's the total possible ways of doing it? h(n)

9)Lowest Common Ancestor of two tree nodes
    a)What if the tree is BST: simple
        Search the tree find the Node node where (node.val-src.val)*(node.val-dest.val) < 0 ||
        node == src || node == dest
    b)What if the node has parent pointer?
        Similar to find the last common node for two linked List that diverges
    c)What if it is a generic binary tree?
        Using recursion:
        a) return two lists of the ancestors and compare the first non-common node
        b) LCA() returns null if root does not contain any of the two, otherwise return root or         root.left/root.right

/****************************************************************/
/****Topic 2: Recursion & Dynamic Programming********************/
/****************************************************************/
1)Return all possible subsets of a collection of integer S, with each subset in increasing order
  a)[combination]Iterative : ans(k+1) = ans(k) +: ans(k).append(S[k+1])
  b)What if there might be duplicates in the collection?
    consider the case of S[k] == S[k+1], there is only several subsets in ans(k) needs
    to be updated with S[k+1], the size of ans(k) will help determine what are the subsets
    if ans(k) is also ordered
  c) Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
    //Method1:Use the same way as b), but remember to remove the subsets with size > k
    //Method2:combine(n,k) recursion to combine(i-1,k-1) for i = k...n
  d)return all possible letter combinations that a phone number can represents
    eg. "23" ->["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
    //same as c)
2)Permutation Sequence
    The set [1,2,3,…,n] contains a total of n! unique permutations.
    By listing and labeling all of the permutations in order,
    We get the following sequence (ie, for n = 3):
        "123"
        "132"
        "213"
        "231"
        "312"
        "321"
    Given n and k, return the kth permutation sequence.
    Note: Given n will be between 1 and 9 inclusive.
    //See answer a recursion with:  
    public String getPermutation(ArrayList<Integer> digits, int k)




1)Regular expression matching with . and * support



/****************************************************************/
/****Topic 3: Hashing, Searching & counting**********************/
/****************************************************************/





/****************************************************************/
/****Topic 4: Graph**********************************************/
/****************************************************************/
1)Min&Max Depth of a tree
    See 4) of Topic 1


/****************************************************************/
/****Topic 5: Tricks*********************************************/
/****************************************************************/
1)Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
