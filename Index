Problems Index
//******//
Best practise:
1)Draw example in draft/sketch
2)Generate test cases to run the code

Something to Look at:
1)Java Generic operations on Deque/PriorityQueue/Stack
2)Prepare Questions to ask
3)Prepare Project highlights and contributions
4)Prefix Tree/String matching Algorithm

/****************************************************************/
/****Topic 1: Tree***********************************************/
/****************************************************************/
1)Populating Next Right Pointers in Each Node O(1) space O(N) time  
    a)Any binary tree
    leverage parent next pointer, consider different cases for left/right children

2)Flatten Binary Tree to Linked List, using rightChild link as next pointer
    a)PreOrder solution[LeetCode]
    b)If the BinaryTree is search tree, return in-order solution[NonLeetCode]
    Keep track of leftMost/rightMost for each node, update accordingly in recursion   
    c)Convert Sorted Array to Balanced Binary Search Tree
    //Binary Cut Recursion 
    d)Convert Sorted List to Balanced Binary Search Tree [Practice]
    //convert to ArrayFirst or do it with nice recursion 
    e) Determine if a BST is valid
    (Needs MetaData min, max, isValid) 

3)Sum of Path(from root to leaf) equals to K
    a)determine if there is one solution
    b)fetch all solutions
    Recursion with K-root.getValue() down to root children, use a shared List to remember path
    and another list to remember all results
    c)If the path may start/end at any node in the tree(rather than only from root to leaf), find the max sum
    //Recursion with MetaData{
        int maxPathRootWithNode
        int maxPathUnderSubTreeNode
    }see LeetCode Solution for detailed relationship    
    d)Sum Root to Leaf Numbers(each node only from 0-9 and represents one digit of a number)
    Post Preorder pass parent sum value, Order to retrive sum 

4)Min/Max Depth of a Tree
    a)Max Depth of a Tree can do simple recursion but Min Depth cannot, as null return 0, max depth will not be affected, however, minDepth will cause a node with one null child and another not null child is not height 1, but non-null child height+1
    b)Therefore Max depth works for simple recursion but MinDepth needs more check
    c)We can use BFS to solve the problem, Min is the nearest leaf node return and Max is the farthest leaf node return (How to keep track of level: swap two lists or use two seperate Queue)
    d)Balanced Binary Search Tree
    //Similar recursion but needs two information, height and isBalanced, can use integer -1 to merge these two information in one data type 
    // If the defination 'Balanced' means max/min leaf depth differs no more than 1, it's a different problem

5)Binary Tree Level Order Print
    a)From Top to bottom, print level
    //BFS with MetaData, Two Queue, Multiple Lists
    b)Pring from bottom to top
    //Insert in the front of the list, or use a stack to reverse, or just reverse
    c)From top to bottom in Zig-Zag
    //multiple lists: use a lable to mark left-right/right-left insert into the List 
    //Queue:Use a stack to reverse in case of need reverse

6)From In Order + (Post/Pre Order) to construct a Binary Tree
    a)Post+Pre does not work

7)Tree Similarity
    a)Determine if it is same tree?
    b)Determine if it is symmetric tree?

8)Structureally unique Binary Search Trees for nodes from 1 to N
    a)How many of them?How to build them?
    //use recursion, combinations of possible left/right children node numbers
    h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (where n>=2，h(0) = h(1) = 1) 
    [Catalan Number]    h(n)=C(2n,n)/(n+1) (n=1,2,3,...)
    b)n pair of parenthesis, how many possible ways to match them?
    //f(2n) = f(0)*f(2n-2) + f(2)*f(2n - 4) + ... + f(2n - 4)*f(2) + f(2n-2)*f(0)
    //f(0)*f(2n-2) means the 0th and 2n-1th element matches, and then it goes recursively to
    //the 2n-2 elements in the between; f(2n) = h(n)
    //see solution for generating all these parenthesis, and this can also be solved using DFS
    //basically backtracking...
    c)one infinite stack has in-stack sequece 1,2,3...n-1,n, what's the number of possible
    out-stack sequence? h(n) how about out-stack 1,2,3,...n and possible ways of in-stack?
    d)2n points on the circule, the number of ways to connect the 2n points using n lines
    e)n matrix multiply chain, the ways to parenthesis the chain is h(n): P=a1×a2×a3×……×an
    f)number of ways from (0,0) to (n,n): only right, and up is allowed and cannot exceed the diagnose, h(n)
    g)2K people in two row, each row has n people and sorted by increasing height order, the person in the back row has to be higher than the person in front of him, what's the total possible ways of doing it? h(n)

9)Lowest Common Ancestor of two tree nodes
    a)What if the tree is BST: simple
        Search the tree find the Node node where (node.val-src.val)*(node.val-dest.val) < 0 ||
        node == src || node == dest
    b)What if the node has parent pointer?
        Similar to find the last common node for two linked List that diverges
    c)What if it is a generic binary tree?
        Using recursion:
        a) return two lists of the ancestors and compare the first non-common node
        b) LCA() returns null if root does not contain any of the two, otherwise return root or         root.left/root.right

/****************************************************************/
/****Topic 2: Recursion & Dynamic Programming********************/
/****************************************************************/
1)Return all possible subsets of a collection of integer S, with each subset in increasing order
  a)[combination]Iterative : ans(k+1) = ans(k) +: ans(k).append(S[k+1])
  b)What if there might be duplicates in the collection?
    consider the case of S[k] == S[k+1], there is only several subsets in ans(k) needs
    to be updated with S[k+1], the size of ans(k) will help determine what are the subsets
    if ans(k) is also ordered
  c) Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
    //Method1:Use the same way as b), but remember to remove the subsets with size > k
    //Method2:combine(n,k) recursion to combine(i-1,k-1) for i = k...n
  d)return all possible letter combinations that a phone number can represents
    eg. "23" ->["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
    //same as c)
2)Permutation Sequence
    The set [1,2,3,…,n] contains a total of n! unique permutations.
    By listing and labeling all of the permutations in order,
    We get the following sequence (ie, for n = 3):
        "123"
        "132"
        "213"
        "231"
        "312"
        "321"
    Given n and k, return the kth permutation sequence.
    Note: Given n will be between 1 and 9 inclusive.
    //See answer a recursion with:  
    public String getPermutation(ArrayList<Integer> digits, int k)
3)Unique Permutation
    Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,
    [1,1,2] have the following unique permutations:
    [1,1,2], [1,2,1], and [2,1,1].
    //Solution: recusion, but stop before the first element same as the integer being inserted

4)Combination Sum problem
  a)Combinations sum without duplicates
    //(0-1knapsack): difficult to remove duplicates recursions
    //Recursion DFS easier to code, however it is less efficient
    // in order to remove duplicates, either put the results in the interface and reset flag
    // or use return value and use the index to check if the same value index is being used
    //Conclusion: in case of duplication may happen, DFS with Results in interface and flag is much easier to code with

  b)Combinations sum with duplicates():
    //Recursion

5)Kanpsack http://blog.csdn.net/hhygcy/article/details/3955683
    a)Change Making Problem
    b)SubsetSum(Unique Subset would be good)
    c)Set parition to minimize the difference

6)Spirial Matrix
    a)Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
    //very easy to break the boundary condition, should test carefully 
    //Boundary condition is: one column
    b)Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.
    //This is an easier recursion

7)Restore IP address from a String:
    //DFS analogous process
    //Boundary check: when should be 0 invalid? what is the range of IP Address?
  a)Suduku Solver
        DFS

8) Triangle Problem
    a)minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
    //bottom-up, save space(save initialization), only one instance of n array needs to be used
    // if keep using top-down, right to left can also save space usage
    //so the direction of recursion: top-down/bottom-up or left-right, right-left can help simplify the solution 
    b)Pascal Triangle
    //top-down

9) Subsequence problems
    a)Distingct Subsequences
    //One Dimension DP, needs sum on previous result
    b)Interleaving String
    //Two dimension DP, only one step recursion, therefore can be optimized using one dimension
    c)Longest Parlindromic Substring
    //Similarly with b), Two dimension DP, one step recursion, can be optimized using one dimension
    TODO d): Longest increasing subsequence
    e) Edit distance:
    //one step, two dimention DP. can be optimzed using O(N) space
    //similar with longest common subsequence

10) Two step recursion to smaller problem, constant space
    a) Decode digits into Alphabetic characters
    b) Fibnacci Number
    c) Ways to sum up to N points from win/tie/lose

11)Scramble String:
    //Three dimension recursion
    //boundary and relation constraint between three dimensions
    //error in boundary of recursion see ERROR in code

12)Regular expression matches:
    Wild card matching:regular expression matching
    //DP is a good way to solve, however TLE, only greedy passes
    //Inner and outter two while loop
    //Greedy impl is very hard

    Regular expression matching with . and * support
    //very careful implementation, two dimentional dp but only two steps look-back
    //therefore eligible for space optimization

13)Jump Game
    //boolean problem: for loop, update max(which is boundary of the loop)
    //min step problem: for loop, maintain a interval of current jump times, update the interval

14) Max rectangular:
    //two dimension DP or use a stack/List to maintain increasing hight of rectangulars

15) BackTracking:
    1)Generate Valid Parenthesis: keep consistant relationship See 1.8: Remaining Right>= Left
    2)DFS
    3)Permutation, Combination
    4)NQueens Problem

16) Unique Paths
    a)Simple one step DP, can be optimized using O(n) space
    //very similar to 12), but a extention to 2D
    b)if the step to right has to be smaller than down, see Topic 1.8 (f
    c)If there is obstacle
    //consider both direction would be affected(max/first?)
    

/TODO:/    
12)Two dimension Maximum subarray

/****************************************************************/
/****Topic 3: Hashing, Searching & counting**********************/
/****************************************************************/
1)Binary Search
    //be careful about the << precedence
    a)Simple Exact search of key
    b)Search first/last occurance of key 
        //search range(left,right) for matched Key
    c)Search hard/soft upper/lowwer boundary with key
        // search 2DMatrix
    d)Search target with rotated array(no duplicates)
    e)Search minimum in rotated array
    f)Search Kth minimum in rotated array
    g)Search Kth minimum in union of two sorted array
        // O(K) or log(m) + log(n)
    h)Search median in union of two sorted array
        //odd number and even number is different
    i)find integer square root
    j)Search kth number from m servers:
        using K size Heap
        using array and merge
    k)Find Median of two sorted array in long(m+n)
        use j) method, even number and odd number cases are different
    TODO:matrix has all rows/columns sorted, find a key in the matrix
    //use a special location of the matrix as pivot

2)K values in an Array sum to S
    a) when k = 2, the best two solution is 
        O(n) space hashtable and O(n) time, find all pairs, use ordering to make sure no duplicates
        O(1) space and O(nlogn) time, firstly sort, the use two pointers move

    b) when k = 3, the best two solution is 
        solution 1: for each value v, do a) it will be O(n^2) time and O(n) space
        solution 2: O(nlogn) sort, then do n times two array check (n^2), this method would support find NEAREST solution, how to make sure the triple in increasing order?

    c) when k = 4, use any two pairs to build pair sum map <sum List<Pair>> in O(n^2), and reduces to two sum problem O(n^2) enforce results only have fours in order 
        how to make sure there is no duplicates is very tricky and difficult

3)Roman & Integer
    1)Roman2Integer:
        find the val for each character, negative the val if next character has higher val
        sum all val
    2)Integer2Roman:
        for each pos, mapps 0-3, 4, 5,6-8,9 to the char value
        appendAll
4)Anagrams
    sort before hashing

/****************************************************************/
/****Topic 4: Graph**********************************************/
/****************************************************************/
1)Min&Max Depth of a tree
    See 4) of Topic 1


/****************************************************************/
/****Topic 5: Tricks*********************************************/
/****************************************************************/
1)Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
//Solution: O(n) interseting strcutre of least significant digits, the break point is the first node that has any lements right of it, but greater than it, we can then replace the point with smallest bigger element and sort the others. As the strcuture of the array, we can simply do it linear
//very similar to bucketing solution (2) in Topic 7

2)Two pointers trick
    2.1)Same array: Two pointers advances
        a)Longest substring without repeating Characters
        b)Two/Three sum to S or Two/Three sum closest to S
        c)Longest valid parentheses
            //keep the difference count and start/end
        d)Max subsum Array

    2.2)Same Array: Two pointers merge
        a)is String Parlidrome
        b)Container with max water
        c)Reverse an Integer with no extra space(keep in mind if not with any string, overflow can happen)
        d)Palindrome Integer(all negative false, especially the Integer.Min, otherwise use two pointers merge)
        e)three color sort, need to keep remember the boundary between first two

    2.3 Same array: Two passes of opposite direction
        see 8)

    2.4 Two arrays: Two pointers on two array advance together
        see Topic DP.12)

3)LinkedList Implementation
    a)Swap LinkedList nodes in pair of Two,Reverse LinkedList in group of K, Reverse Linked List from M to N
        // Use helper, and a helper function reverse from node m to node n
        //for reverse in group of K, either use recursion
        //or use one more variable pre(started with helper) to avoid recursion
    b)Remove duplicates from sorted List (either all duplicated entries or remove duplicates)
        // Use helper, very careful to implement the loop
    c)Two pointer trick:
        (a)Remove Nth from the end of the List
        (b)Detect Circle and return beginning of the circle
            two pointers traverse at different speed of traverse, find the position the two pointers meet,
            use the third pointer to start, and the first pointer start at the same time, these two pointers will meet at beginning of the             circle
        (c)Detect the first common node of two merged lists
            two pointers traverse to the end to figure out length of the two, and then two pointers restart traverse with length diff
            the two pointers will meet at the beginning of the two merged lists
    d)Rotate List by K
        // check relationship between k and size of the list
        // helper is useful in implementation, and remember to connect tail to head
    e)Partition List
        // use helper helps a lot
    f)Merge K sorted Lists
        //use min Heap
        //merge two sorted Arrays/Lists

4)constant space problem usually means a) solvable by only several variable b) solvable by using input data strucutre(SWAPPING)
    a)Find First Missing positive integer
        Swap to move integer i into A[i-1], the condition to stop swapping: in range + not equal swap 
    b)Set matrix zeros with constant space
    //be careful about the first line/column
5)Observation and Analysis
    a)Trap drain water
    b)Longest Valid Parentheses
        //only position instead of character will be needed to push
    c)Merge/Insert Intervals
        // how to use comparable+compare/comparator+compare
        // how to decide to intervals overlaps
        //for loop control
6)Rotating
    a)90 degree clock-wise rotate image

8)Best time to sell stock
    single transaction(compare max), infinite transactions, double transactions(O(N))
    //double transaction can use two passes of two different directions

9)Get Sum/Union of two string/array
    a)Add Binary: Reverse, char/integer, carry
    b)Sum two String of base K

/****************************************************************/
/****Topic 7: Big Data*******************************************/
/**********************************************************r*****/
KEY:
    1)Firstly look at if there is data struture can load all data in a single node:
      bitMap, Trie, two-level-bucketing, or bloom filter
    2)If not, let's do paritioning to different nodes(hashing/bucketing)  
    3)If only one machine is allowed or we want to save IO between different machines, we can put all paritions on the same machine and reduce them all together
    4)Reduce the problem into final results using external sort/heap/merge sort

1) Trie Tree n words, avg length len(h)--> build time n*len = n*h, single query time: O(len)=O(h) space:
O(n*len)
    Think of Trie as a hash tree specialized in string(optimized for string comparision)

    a)one text file of 10k lines, one word each line, find out top m frequent words
        assume there are n (n<10k) disctinct words: O(10k*len+ n*lgm) 
    b)1G file with only 1M memory can be used, one word each line, and upper limit for each word is 16 byte
        partition; trie+heap to find max k
    c)10G strings with duplicates,remove duplicates
        partition; trie+heap to find max k
    d) query word limit is 255 byte, total 10G query, in total 3 million distinct words, find top k query words with max 1G memory
        3M*255 < 10G, therefore can be loaded into memory: Trie or HashTable
        Use a heap
    e) Another important usage for trie is text/phone number completion 


2)Two(Multi)-level bucketing: especially useful for finding median number
    Think of bucketing a range hashing(partitioning) method and can keep the original  sequence:
    a) 500G 32-bit/64-bit integers, how to find median number with several M memory
        A interger range can be used for direct address: 2^20 = 1M
        two/three level bucketing the integers, and you will be able to know the xth
        of a smaller level bucket
    b)5G integers, find all the integers has no dupliates
        bucketing + bitmap for each bucket
         
3)Hashing partition (for marking or counting, then sort/heap), for limited size integer/string, Trie tree is applicable to help
    all problem of 1) can be solved with hashing parition then reducing the results
    in terms of: counting, top k, removing/keep dupliates, or two dataset similarity comparision


4)Bloom Filter: can be used as dictionary error allowance, n items, m bits, hashtable number k, and error rate e
k = ln2*(m/n) error rate is smallest, 
m >= 1.44n*log(1/e) 
counting filter to support deletion
    a)5G URLs each URL is of 64 bytes, with 4G memory
        m>= 1.44*n*log100 = 10n = 10*5G/8 = ~5G, therefore we can use bloom filter
5)Bitmap: Especially useful for integers labeling, check for existance,but not support counting
    if we use bit size of 2 instead of 1, we can determine if there is duplicates
6)Inverted Indexing becomes useful when document concerned.
    web/doc key word search, search engine
7)Map reduce
    a)count appearance of each word in a set of documents
    b)We have N machines and each can process O(N) numbers, we have O(N^2) numbers, how to find
    meidan number for them?
    //sort+merge sort

8)Pagination and indexing: A very big file cannot be loaded into memory, one integer each line, how to find 100 random values from the big file?
    //paginating the dataset, generate a random key and use the key to get the indexed value

9)LBS: location based search
    1)Geo hashing: not sufficient though
    http://iamzhongyong.iteye.com/blog/1399333
    http://www.cnblogs.com/dengxinglin/archive/2012/12/14/2817761.html
    2) R Tree
    http://blog.csdn.net/v_july_v/article/details/11288807
