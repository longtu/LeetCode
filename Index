Problems Index
//******//
Best practise:
1)Draw example in draft/sketch
2)Generate test cases to run the code

Something to Look at:
1)Java Generic operations on Deque/PriorityQueue/Stack
2)Prepare Questions to ask
3)Prepare Project highlights and contributions
4)Prefix Tree/String matching Algorithm

/****************************************************************/
/****Topic 1: Tree***********************************************/
/****************************************************************/
1)Populating Next Right Pointers in Each Node O(1) space O(N) time  
    a)Any binary tree
    leverage parent next pointer, consider different cases for left/right children

2)Flatten Binary Tree to Linked List, using rightChild link as next pointer
    a)PreOrder solution[LeetCode]
    b)If the BinaryTree is search tree, return in-order solution[NonLeetCode]
    Keep track of leftMost/rightMost for each node, update accordingly in recursion   
    c)Convert Sorted Array to Balanced Binary Search Tree
    //Binary Cut Recursion 
    d)Convert Sorted List to Balanced Binary Search Tree [Practice]
    //convert to ArrayFirst or do it with nice recursion 
    e) Determine if a BST is valid
    (Needs MetaData min, max, isValid) 

3)Sum of Path(from root to leaf) equals to K
    a)determine if there is one solution
    b)fetch all solutions
    Recursion with K-root.getValue() down to root children, use a shared List to remember path
    and another list to remember all results
    c)If the path may start/end at any node in the tree(rather than only from root to leaf), find the max sum
    //Recursion with MetaData{
        int maxPathRootWithNode
        int maxPathUnderSubTreeNode
    }see LeetCode Solution for detailed relationship    
    d)Sum Root to Leaf Numbers(each node only from 0-9 and represents one digit of a number)
    Post Preorder pass parent sum value, Order to retrive sum 

4)Min/Max Depth of a Tree
    a)Max Depth of a Tree can do simple recursion but Min Depth cannot, as null return 0, max depth will not be affected, however, minDepth will cause a node with one null child and another not null child is not height 1, but non-null child height+1
    b)Therefore Max depth works for simple recursion but MinDepth needs more check
    c)We can use BFS to solve the problem, Min is the nearest leaf node return and Max is the farthest leaf node return (How to keep track of level: swap two lists or use two seperate Queue)
    d)Balanced Binary Search Tree
    //Similar recursion but needs two information, height and isBalanced, can use integer -1 to merge these two information in one data type 
    // If the defination 'Balanced' means max/min leaf depth differs no more than 1, it's a different problem

5)Binary Tree Level Order Print
    a)From Top to bottom, print level
    //BFS with MetaData, Two Queue, Multiple Lists
    b)Pring from bottom to top
    //Insert in the front of the list, or use a stack to reverse, or just reverse
    c)From top to bottom in Zig-Zag
    //multiple lists: use a lable to mark left-right/right-left insert into the List 
    //Queue:Use a stack to reverse in case of need reverse

6)From In Order + (Post/Pre Order) to construct a Binary Tree
    a)Post+Pre does not work

7)Tree Similarity
    a)Determine if it is same tree?
    b)Determine if it is symmetric tree?

8)Structureally unique Binary Search Trees for nodes from 1 to N
    a)How many of them?How to build them?
    //use recursion, combinations of possible left/right children node numbers
    h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (where n>=2，h(0) = h(1) = 1) 
    [Catalan Number]    h(n)=C(2n,n)/(n+1) (n=1,2,3,...)
    b)n pair of parenthesis, how many possible ways to match them?
    //f(2n) = f(0)*f(2n-2) + f(2)*f(2n - 4) + ... + f(2n - 4)*f(2) + f(2n-2)*f(0)
    //f(0)*f(2n-2) means the 0th and 2n-1th element matches, and then it goes recursively to
    //the 2n-2 elements in the between; f(2n) = h(n)
    c)one infinite stack has in-stack sequece 1,2,3...n-1,n, what's the number of possible
    out-stack sequence? h(n) how about out-stack 1,2,3,...n and possible ways of in-stack?
    d)2n points on the circule, the number of ways to connect the 2n points using n lines
    e)n matrix multiply chain, the ways to parenthesis the chain is h(n): P=a1×a2×a3×……×an
    f)number of ways from (0,0) to (n,n): only right, and up is allowed and cannot exceed the diagnose, h(n)
    g)2K people in two row, each row has n people and sorted by increasing height order, the person in the back row has to be higher than the person in front of him, what's the total possible ways of doing it? h(n)

9)Lowest Common Ancestor of two tree nodes
    a)What if the tree is BST: simple
        Search the tree find the Node node where (node.val-src.val)*(node.val-dest.val) < 0 ||
        node == src || node == dest
    b)What if the node has parent pointer?
        Similar to find the last common node for two linked List that diverges
    c)What if it is a generic binary tree?
        Using recursion:
        a) return two lists of the ancestors and compare the first non-common node
        b) LCA() returns null if root does not contain any of the two, otherwise return root or         root.left/root.right

/****************************************************************/
/****Topic 2: Recursion & Dynamic Programming********************/
/****************************************************************/
1)Return all possible subsets of a collection of integer S, with each subset in increasing order
  a)[combination]Iterative : ans(k+1) = ans(k) +: ans(k).append(S[k+1])
  b)What if there might be duplicates in the collection?
    consider the case of S[k] == S[k+1], there is only several subsets in ans(k) needs
    to be updated with S[k+1], the size of ans(k) will help determine what are the subsets
    if ans(k) is also ordered
  c) Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
    //Method1:Use the same way as b), but remember to remove the subsets with size > k
    //Method2:combine(n,k) recursion to combine(i-1,k-1) for i = k...n
  d)return all possible letter combinations that a phone number can represents
    eg. "23" ->["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
    //same as c)
2)Permutation Sequence
    The set [1,2,3,…,n] contains a total of n! unique permutations.
    By listing and labeling all of the permutations in order,
    We get the following sequence (ie, for n = 3):
        "123"
        "132"
        "213"
        "231"
        "312"
        "321"
    Given n and k, return the kth permutation sequence.
    Note: Given n will be between 1 and 9 inclusive.
    //See answer a recursion with:  
    public String getPermutation(ArrayList<Integer> digits, int k)
3)Unique Permutation
    Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example,
    [1,1,2] have the following unique permutations:
    [1,1,2], [1,2,1], and [2,1,1].
    //Solution: recusion, but stop before the first element same as the integer being inserted

4)Combination Sum problem
  a)Combinations sum without duplicates
    //(0-1knapsack): difficult to remove duplicates recursions
    //Recursion DFS easier to code, however it is less efficient
    // in order to remove duplicates, either put the results in the interface and reset flag
    // or use return value and use the index to check if the same value index is being used
    //Conclusion: in case of duplication may happen, DFS with Results in interface and flag is much easier to code with

  b)Combinations sum with duplicates():
    //Recursion

5)Kanpsack http://blog.csdn.net/hhygcy/article/details/3955683
    a)Change Making Problem
    b)SubsetSum(Unique Subset would be good)
    c)Set parition to minimize the difference

6)Spirial Matrix
    a)Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
    //very easy to break the boundary condition, should test carefully 
    //Boundary condition is: one column
    b)Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.
    //This is an easier recursion

7)Restore IP address from a String:
    //DFS analogous process
    //Boundary check: when should be 0 invalid? what is the range of IP Address?

8) Triangle Problem
    a)minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
    //bottom-up, save space(save initialization), only one instance of n array needs to be used
    // if keep using top-down, right to left can also save space usage
    //so the direction of recursion: top-down/bottom-up or left-right, right-left can help simplify the solution 
    b)Pascal Triangle
    //top-down

9) Subsequence problems
    a)Distingct Subsequences
    //One Dimension DP, needs sum on previous result
    b)Interleaving String
    //Two dimension DP, only one step recursion, therefore can be optimized using one dimension
    c)Longest Parlindromic Substring
    //Similarly with b), Two dimension DP, one step recursion, can be optimized using one dimension

10) Two step recursion to smaller problem, constant space
    a) Decode digits into Alphabetic characters
    b) Fibnacci Number
    c) Ways to sum up to N points from win/tie/lose

11)Scramble String:
    //Three dimension recursion
    //boundary and relation constraint between three dimensions
    //error in boundary of recursion see ERROR in code

13)Jump Game
    //boolean problem: for loop, update max(which is boundary of the loop)
    //min step problem: for loop, maintain a interval of current jump times, update the interval


/TODO:/    
12)Two dimension Maximum subarray
14)Wild card matching:regular expression matching
15)Regular expression matching with . and * support




/****************************************************************/
/****Topic 3: Hashing, Searching & counting**********************/
/****************************************************************/
1)Binary Search
    a)Simple Exact search of key
    b)Search first/last occurance of key 
    c)Search hard/soft upper/lowwer boundary with key
    d)Search target with rotated array(no duplicates)
    e)Search minimum in rotated array
    f)Search Kth minimum in rotated array
    g)Search Kth minimum in union of two sorted array
        // O(K) or log(m) + log(n)
    h)Search median in union of two sorted array
        //odd number and even number is different
    i)find integer square root
    j)Search kth number from m servers:
        using K size Heap
        using array and merge
    k)Find Median of two sorted array in long(m+n)
        use j) method, even number and odd number cases are different

2)K values in an Array sum to S
    a) when k = 2, the best two solution is 
        O(n) space hashtable and O(n) time, find all pairs, use ordering to make sure no duplicates
        O(1) space and O(nlogn) time, firstly sort, the use two pointers move

    b) when k = 3, the best two solution is 
        solution 1: for each value v, do a) it will be O(n^2) time and O(n) space
        solution 2: O(nlogn) sort, then do n times two array check (n^2), this method would support find NEAREST solution, how to make sure the triple in increasing order?

    c) when k = 4, use any two pairs to build pair sum map <sum List<Pair>> in O(n^2), and reduces to two sum problem O(n^2) enforce results only have fours in order 
        how to make sure there is no duplicates is very tricky and difficult




/****************************************************************/
/****Topic 4: Graph**********************************************/
/****************************************************************/
1)Min&Max Depth of a tree
    See 4) of Topic 1


/****************************************************************/
/****Topic 5: Tricks*********************************************/
/****************************************************************/
1)Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
//Solution: O(n) interseting strcutre of least significant digits, the break point is the first node that has any lements right of it, but greater than it, we can then replace the point with smallest bigger element and sort the others. As the strcuture of the array, we can simply do it linear

2)Two pointers trick
    a)Longest substring without repeating Characters
    b)Two/Three sum to S or Two/Three sum closest to S
    c)

3)LinkedList Implementation
    a) Swap LinkedList nodes in pair of Two 
       // Use helper
4)constant space problem usually means a) solvable by only several variable b) solvable by using input data strucutre(SWAPPING)
    a)Find First Missing positive integer
        Swap to move integer i into A[i-1], the condition to stop swapping: in range + not equal swap 
5)Observation and Analysis
    a)Trap drain water
