##bit-manipulation:
    use 1<<shifts to achieve range limit or make mask, e.g. IntegerMax = 1<<32-1;
Repeated DNA Sequences:
	use integer encoding of different characters, bit operation will help



##Dynamic programming:
Buy/Sell Stock :
	-Use local/global relations
 	-Remember to leverage variable type default values from JAVA spec: boolean->false, numeric/char->0, reference->null
 	-Once you use two array optimization instead of full array, the inner/outer loop relationship CANNOT be easily switched

Distinct Subsequence
	- Use local/global optimal relations

Max sum subarray //skip
	- Use local/global optimal relations
	- Extention is max product subarray

Longest Substring Without Repeating Characters
	- Use local/global optimal relations
	- use hashtable to record last position for given character
	- However watch out for local optimal is not (i - table.get(charAt(i))), there might be duplicates in between

Parlindrome Paritioning II
    - find all Parlindromes first
    - Use local/global optimal relations
    - Made mistakes

Climbing Stairs/Decode ways/Fibnacci/:
	-split into initialization and recursive phase
	-initialization phase: set up initial value, however this initial value may not be the same as result of this edge ca   ase when n = 0
 	-sol[0] base cannot be computed in recursive loop (while/for)
 	-Once using constant space optimization, remember to reset the values !!
 	-Once use while for loop, remember to increment i !!!

Triangle:		//skip
    -Similar 1-dimension recursive relationship
    -however we can go from bottom up instead of top down to speed up and easy to code

Unique Paths(I,II)/Minimum Path Sum	//skip
 	-Two dimension extention of Fibnacci

Word Distance()
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
 	-Recursive relationship is a little bit difficult to figure out.

Scramble String
	-Comparing with Word Distance, two source relationship subproblem structure
	-Implementation very easily can cause bugs: break for different sublengths, look up, check the code...

Interleaving Sting
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
	-recursive relationship boundary, watch out for what values to use

Unique BSTs I/II 	//skip
	 -Traditional bigger/smaller problem;
	 -Still similar to two dimension extention of Fibnacci, but there are very large number of smaller problem can be reduced to

Word Break
    -use valid lengths from dictionary to parse string
	-use BFS or DFS(LTE unless use tuning)
	-Word BreakII returns all lists, using DFS is much easier to code
	-无节操剪枝

Largest Rectangular //skip optimal, but not TLE
	-recursive relationship
	-What is stored in meta data results

Regular Expression Matching ////skip optimal, but not TLE
    -simple recursive relationship
    -but tooooo many edge cases!!!
    -need to redo to catch all edge cases

Wild Card Matching //skip optimal, but not TLE
    -simple recursive relationship
	-无节操剪枝
    -need to check how to prune

Longest Valid Parentheses //skip optimal solution, still TLE
	-change its problem to be has valid parenthesis
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
	-Recursinve relathionship boundary
	-Optimal solution should be O(N)

##Tree:
Binary Search Tree In-order Traversal Iterator:
	-In order iterator: Use a stack O(h) space, O(1) time
	-Pre order: Use a stack o(h) space
	-Post order: use a stack o(h)  as well, just some cases to take care
	-Post order can also reverse pre-order results
	-Java Stack is a class, not interface
	-Level-by-level iterator: Use a queue,  O(N) space
	-Level-by-level iterator(bottom-up): use swap queues + Stack(or linkeList, more simpler)    //worth another try
	-Zig-Zag: Use swap queues and linkedlist, use a reverse label to addFirst/Last  //worth another try

Tree UpsideDown: // needs practice
	-Iterative solution is clean and good, but could be easier
	-Did not think of the recursive solution

Unique Binary Search Trees I/II
    -Use copy tree, convert to a recursive-able function

Validate Binary Search Tree/Sum Root to Leaf Numbers [metadata top down]
	-Pass metadata to children during recursion
	-Watch out for leaf nodes
Path Sum i/ii [need clarification on path!!]
	-Watch out! root to leaft paths only
	-If inner node paths are also valid, we need special care of null nodes (return a list of (empty list but null))

Binary Tree Maximum Path Sum [This needs special care!!!][metadata bottom up]***
	-when null case is simple, leaf case may need special care!!
	-when null return null, use null check to set default value

min/max Tree Depth [metadata bottom up]
	-use recursion
	-watch out for null/leaf nodes/non-leaf nodes
Balanced Trees [metadata bottom up]
	-use recursion, keep track of height from bottom up

Populating Next Right Pointers In Each Node i/ii ***
	-implementaiton test:
	- use node, parent,  (and leftmost)
	- helper function
	- helper parent

Flatten Binary Tree to Linked List
	-Recursion for different types of node

Convert Sorted Array to Binary Search Tree
	-recursive
	-use startInclusive, endExclusive, mid = (start+end)/2

Construct Binary Tree from Inorder and Postorder/Pre Traversal ***
	-leverage the length differentce from In-Order Range
	-watch out for where pre/post traversal start/end

Recover Binary Search Tree ***
	-edge case is when two neighbour nodes are swapped
	-use recursion/stack in-order iteration to find exceptions (watch out for this code)

Same Tree //skip
Symmetric Tree //skip

#Back tracking
Sudoku Solver
	-Backtrack Recursion
	-Remember to reset original state!!!

#Math Trick
Majority Element ***
	-figures out the relationship to cancel
	-but not realized to use a count variable!!!
Max Points on a Line
	- watch out for single point
	- watch out for same points as origin
	- use hashtable to store ratio

#Sorting
Maximum Gap ***
	-too native exhaust will fail
	-Implement radix sort (how to find index for each filed)

Sort Colors ***
	-counting sort
	-use firstOne, next, end to track parition
	-watch out for maintains firstOne


#Iterative, implementation
Excel Sheet Column Title ***
	-string to integer is easy
	-integer to string has to be careful!!!
	-each filed is shifted by one bit

Factorial Trailing Zeroes
	-count how many 5, 5*5, 5*5*5 etc
	-integer overflow

Fraction to Recurring Decimal ***
	-the recursion relationship
	-integer overflow
	-any operation of intger we need to use long

#Two pointers
###CHASING POINTERS
Minimum Window Substring ***
	- sub-optimal: use start/end
	- each test is not o(1)
	- optimal solution : use a variable--sum of all chars, still need dictionary, see http://fisherlei.blogspot.com/2012/12/leetcode-minimum-window-substring.html

###MEETING POINTERS
4Sum/2Sum
	- use hashtable to remove duplicates
	- use iteration to reduce to two sum
	- need to check optimal solution
	- two pointers
valid palidrome
	-two pointers
maxArea
	-two pointers meet
	-update max and which boarder to move

###LAG POINTERS
Rotate List ***
	- '''use distance between two pointers to control loop'''

Remote Nth from end of List ***
	- '''use distance between two pointers to control loop'''
	- watch out for empty list and when len == 0
	- mod does not make sense

###EXHAUSTIVE COMBINATION POINTERS
Strstr
	-KMP/Boyer-Moore
	-two pointers, watch out for empty or null

Substring with Concatenation of All Words ***
	-Optimization of early stop
	-Use a map as word count, test if each index statisfies the word count

TODO_OPTIMAL:
Trapping Rain Water
	-left/right max
