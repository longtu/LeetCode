bit-manipulation:
    use 1<<shifts to achieve range limit or make mask, e.g. IntegerMax = 1<<32-1;

##Dynamic programming:
Buy/Sell Stock :
	-Use local/global relations
 	-Remember to leverage variable type default values from JAVA spec: boolean->false, numeric/char->0, reference->null
 	-Once you use two array optimization instead of full array, the inner/outer loop relationship CANNOT be easily switched

Distinct Subsequence
	- Use local/global optimal relations

Max sum subarray //skip
	- Use local/global optimal relations
	- Extention is max product subarray

Parlindrome Paritioning II
    - find all Parlindromes first
    - Use local/global optimal relations
    - Made mistakes

Climbing Stairs/Decode ways/Fibnacci/:
	-split into initialization and recursive phase
	-initialization phase: set up initial value, however this initial value may not be the same as result of this edge ca   ase when n = 0
 	-sol[0] base cannot be computed in recursive loop (while/for)
 	-Once using constant space optimization, remember to reset the values !!
 	-Once use while for loop, remember to increment i !!!

Triangle:		//skip
    -Similar 1-dimension recursive relationship
    -however we can go from bottom up instead of top down to speed up and easy to code

Unique Paths(I,II)/Minimum Path Sum	//skip
 	-Two dimension extention of Fibnacci

Word Distance()
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
 	-Recursive relationship is a little bit difficult to figure out.

Scramble String
	-Comparing with Word Distance, two source relationship subproblem structure
	-Implementation very easily can cause bugs: break for different sublengths, look up, check the code...

Interleaving Sting
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
	-recursive relationship boundary, watch out for what values to use

Unique BSTs I/II 	//skip
	 -Traditional bigger/smaller problem;
	 -Still similar to two dimension extention of Fibnacci, but there are very large number of smaller problem can be reduced to

Word Break
    -use valid lengths from dictionary to parse string
	-use BFS or DFS(LTE unless use tuning)
	-Word BreakII returns all lists, using DFS is much easier to code
	-无节操剪枝

Largest Rectangular //skip optimal, but not TLE
	-recursive relationship
	-What is stored in meta data results

Regular Expression Matching ////skip optimal, but not TLE
    -simple recursive relationship
    -but tooooo many edge cases!!!
    -need to redo to catch all edge cases

Wild Card Matching //skip optimal, but not TLE
    -simple recursive relationship
	-无节操剪枝
    -need to check how to prune


Longest Valid Parentheses //skip optimal solution, still TLE
	-change its problem to be has valid parenthesis
 	-Traditional bigger/smaller problem; Two dimension extention of Fibnacci
	-Recursinve relathionship boundary
	-Optimal solution should be O(N)

##Tree:
Binary Search Tree In-order Traversal Iterator:
	-In order iterator: Use a stack O(h) space, O(1) time
	-Pre order: Use a stack o(h) space
	-Post order: use a stack o(h)  as well, just some cases to take care
	-Post order can also reverse pre-order results
	-Java Stack is a class, not interface
	-Level-by-level iterator: Use a queue,  O(N) space
	-Level-by-level iterator(bottom-up): use swap queues + Stack(or linkeList, more simpler)    //worth another try
	-Zig-Zag: Use swap queues and linkedlist, use a reverse label to addFirst/Last  //worth another try

Tree UpsideDown: // needs practice
	-Iterative solution is clean and good, but could be easier
	-Did not think of the recursive solution

Unique Binary Search Trees I/II
    -Use copy tree, convert to a recursive-able function

Validate Binary Search Tree/Sum Root to Leaf Numbers [metadata top down]
	-Pass metadata to children during recursion
	-Watch out for leaf nodes
Path Sum i/ii [need clarification on path!!]
	-Watch out! root to leaft paths only
	-If inner node paths are also valid, we need special care of null nodes (return a list of (empty list but null))

Binary Tree Maximum Path Sum [This needs special care!!!][metadata bottom up]***
	-when null case is simple, leaf case may need special care!!
	-when null return null, use null check to set default value

min/max Tree Depth [metadata bottom up]
	-use recursion
	-watch out for null/leaf nodes/non-leaf nodes
Balanced Trees [metadata bottom up]
	-use recursion, keep track of height from bottom up

Populating Next Right Pointers In Each Node i/ii ***
	-implementaiton test:
	- use node, parent,  (and leftmost)
	- helper function
	- helper parent

Flatten Binary Tree to Linked List
	-Recursion for different types of node

Same Tree //skip
Symmetric Tree //skip

